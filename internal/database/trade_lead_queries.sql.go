// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: trade_lead_queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const adminGetAllTradeLeads = `-- name: AdminGetAllTradeLeads :many
SELECT 
  COUNT(*) OVER() AS total_count,
  id, 
  tenant_id, 
  title, 
  description, 
  status, 
  value, 
  version,
  created_at, 
  updated_at
FROM trade_leads
WHERE ($1 = '' OR to_tsvector('simple', title) @@ plainto_tsquery('simple', $1))
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type AdminGetAllTradeLeadsParams struct {
	Column1 interface{}
	Limit   int32
	Offset  int32
}

type AdminGetAllTradeLeadsRow struct {
	TotalCount  int64
	ID          int64
	TenantID    int64
	Title       string
	Description sql.NullString
	Status      string
	Value       string
	Version     int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) AdminGetAllTradeLeads(ctx context.Context, arg AdminGetAllTradeLeadsParams) ([]AdminGetAllTradeLeadsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetAllTradeLeads, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminGetAllTradeLeadsRow
	for rows.Next() {
		var i AdminGetAllTradeLeadsRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Value,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetTRadeLeadStats = `-- name: AdminGetTRadeLeadStats :one
SELECT 
  COUNT(*)::text AS total_leads,
  COUNT(*) FILTER (WHERE status = 'verified')::text AS verified_leads,
  COALESCE(SUM(value) FILTER (WHERE status = 'verified'), 0)::text AS total_verified_value
FROM trade_leads
`

type AdminGetTRadeLeadStatsRow struct {
	TotalLeads         string
	VerifiedLeads      string
	TotalVerifiedValue string
}

func (q *Queries) AdminGetTRadeLeadStats(ctx context.Context) (AdminGetTRadeLeadStatsRow, error) {
	row := q.db.QueryRowContext(ctx, adminGetTRadeLeadStats)
	var i AdminGetTRadeLeadStatsRow
	err := row.Scan(&i.TotalLeads, &i.VerifiedLeads, &i.TotalVerifiedValue)
	return i, err
}

const adminUpdateTradeLeadStatus = `-- name: AdminUpdateTradeLeadStatus :one
UPDATE trade_leads
SET 
  status = 'verified'
WHERE id = $1 AND version = $2
RETURNING version, status, updated_at
`

type AdminUpdateTradeLeadStatusParams struct {
	ID      int64
	Version int32
}

type AdminUpdateTradeLeadStatusRow struct {
	Version   int32
	Status    string
	UpdatedAt time.Time
}

func (q *Queries) AdminUpdateTradeLeadStatus(ctx context.Context, arg AdminUpdateTradeLeadStatusParams) (AdminUpdateTradeLeadStatusRow, error) {
	row := q.db.QueryRowContext(ctx, adminUpdateTradeLeadStatus, arg.ID, arg.Version)
	var i AdminUpdateTradeLeadStatusRow
	err := row.Scan(&i.Version, &i.Status, &i.UpdatedAt)
	return i, err
}

const createTradeLead = `-- name: CreateTradeLead :one
INSERT INTO trade_leads (
  tenant_id,
  title,
  description,
  value
) VALUES (
  $1, $2, $3, $4
)
RETURNING id,tenant_id, version, created_at, updated_at
`

type CreateTradeLeadParams struct {
	TenantID    int64
	Title       string
	Description sql.NullString
	Value       string
}

type CreateTradeLeadRow struct {
	ID        int64
	TenantID  int64
	Version   int32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateTradeLead(ctx context.Context, arg CreateTradeLeadParams) (CreateTradeLeadRow, error) {
	row := q.db.QueryRowContext(ctx, createTradeLead,
		arg.TenantID,
		arg.Title,
		arg.Description,
		arg.Value,
	)
	var i CreateTradeLeadRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllLeadsByTenantID = `-- name: GetAllLeadsByTenantID :many
SELECT 
  COUNT(*) OVER() AS total_count,
  id, 
  tenant_id, 
  title, 
  description, 
  status, 
  value, 
  version,
  created_at, 
  updated_at
FROM trade_leads
WHERE tenant_id = $1
  AND ($2 = '' OR to_tsvector('simple', title) @@ plainto_tsquery('simple', $2))
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetAllLeadsByTenantIDParams struct {
	TenantID int64
	Column2  interface{}
	Limit    int32
	Offset   int32
}

type GetAllLeadsByTenantIDRow struct {
	TotalCount  int64
	ID          int64
	TenantID    int64
	Title       string
	Description sql.NullString
	Status      string
	Value       string
	Version     int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) GetAllLeadsByTenantID(ctx context.Context, arg GetAllLeadsByTenantIDParams) ([]GetAllLeadsByTenantIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLeadsByTenantID,
		arg.TenantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLeadsByTenantIDRow
	for rows.Next() {
		var i GetAllLeadsByTenantIDRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Value,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradeLeadByID = `-- name: GetTradeLeadByID :one
SELECT 
  id, 
  tenant_id, 
  title, 
  description, 
  status, 
  value, 
  version,
  created_at, 
  updated_at
FROM trade_leads
WHERE id = $1
`

func (q *Queries) GetTradeLeadByID(ctx context.Context, id int64) (TradeLead, error) {
	row := q.db.QueryRowContext(ctx, getTradeLeadByID, id)
	var i TradeLead
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Value,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

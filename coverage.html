
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Blue-Davinci/leadhub-service/cmd/api/context.go (33.3%)</option>
				
				<option value="file1">github.com/Blue-Davinci/leadhub-service/cmd/api/errors.go (30.0%)</option>
				
				<option value="file2">github.com/Blue-Davinci/leadhub-service/cmd/api/healthcheck.go (75.0%)</option>
				
				<option value="file3">github.com/Blue-Davinci/leadhub-service/cmd/api/helpers.go (13.6%)</option>
				
				<option value="file4">github.com/Blue-Davinci/leadhub-service/cmd/api/main.go (0.0%)</option>
				
				<option value="file5">github.com/Blue-Davinci/leadhub-service/cmd/api/middleware.go (55.8%)</option>
				
				<option value="file6">github.com/Blue-Davinci/leadhub-service/cmd/api/routes.go (0.0%)</option>
				
				<option value="file7">github.com/Blue-Davinci/leadhub-service/cmd/api/server.go (0.0%)</option>
				
				<option value="file8">github.com/Blue-Davinci/leadhub-service/cmd/api/tenants.go (0.0%)</option>
				
				<option value="file9">github.com/Blue-Davinci/leadhub-service/cmd/api/trade_leads.go (0.0%)</option>
				
				<option value="file10">github.com/Blue-Davinci/leadhub-service/cmd/api/users.go (0.0%)</option>
				
				<option value="file11">github.com/Blue-Davinci/leadhub-service/internal/data/filters.go (0.0%)</option>
				
				<option value="file12">github.com/Blue-Davinci/leadhub-service/internal/data/internal_helpers.go (0.0%)</option>
				
				<option value="file13">github.com/Blue-Davinci/leadhub-service/internal/data/models.go (0.0%)</option>
				
				<option value="file14">github.com/Blue-Davinci/leadhub-service/internal/data/permissions.go (0.0%)</option>
				
				<option value="file15">github.com/Blue-Davinci/leadhub-service/internal/data/tenants.go (5.6%)</option>
				
				<option value="file16">github.com/Blue-Davinci/leadhub-service/internal/data/tokens.go (0.0%)</option>
				
				<option value="file17">github.com/Blue-Davinci/leadhub-service/internal/data/trade_leads.go (3.5%)</option>
				
				<option value="file18">github.com/Blue-Davinci/leadhub-service/internal/data/users.go (2.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "net/http"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
)

// Define a custom contextKey type, with the underlying type string.
type contextKey string

// Convert the string "user" to a contextKey type and assign it to the userContextKey
// constant. We'll use this constant as the key for getting and setting user information
// in the request context.
const userContextKey = contextKey("user")

// The contextSetUser() method returns a new copy of the request with the provided
// User struct added to the context. Note that we use our userContextKey constant as the
// key.
func (app *application) contextSetUser(r *http.Request, user *data.User) *http.Request <span class="cov8" title="1">{
        ctx := context.WithValue(r.Context(), userContextKey, user)
        //app.log.PrintInfo("set user in request context", map[string]string{"name": user.Name, "email": user.Email})
        return r.WithContext(ctx)
}</span>

// The contextGetUser() retrieves the User struct from the request context. The only
// time that we'll use this helper is when we logically expect there to be User struct
// value in the context, and if it doesn't exist it will firmly be an 'unexpected' error.
// As we discussed earlier in the book, it's OK to panic in those circumstances.
func (app *application) contextGetUser(r *http.Request) *data.User <span class="cov0" title="0">{
        user, ok := r.Context().Value(userContextKey).(*data.User)
        if !ok </span><span class="cov0" title="0">{
                panic("missing user value in request context")</span>
        }
        <span class="cov0" title="0">return user</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "net/http"

        "go.uber.org/zap"
)

func (app *application) logError(r *http.Request, err error) <span class="cov8" title="1">{
        // Use the PrintError() method to log the error message, and include the current
        // request method and URL as properties in the log entry.
        app.logger.Error(err.Error(), zap.String("request_method", r.Method), zap.String("request_url", r.URL.String()))

}</span>

// The errorResponse() method is a generic helper for sending JSON-formatted error
// messages to the client with a given status code.
func (app *application) errorResponse(w http.ResponseWriter, r *http.Request, status int, message any) <span class="cov8" title="1">{
        env := envelope{"error": message}
        // Write the response using the writeJSON() helper. If this happens to return an
        // error then log it, and fall back to sending the client an empty response with a
        // 500 Internal Server Error status code.
        err := app.writeJSON(w, status, env, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.logError(r, err)
                w.WriteHeader(500)
        }</span>
}

// The serverErrorResponse() method will be used when our application encounters an
// unexpected problem at runtime. It logs the detailed error message, then uses the
// errorResponse() helper to send a 500 Internal Server Error status code and JSON
// response (containing a generic error message) to the client.
func (app *application) serverErrorResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        app.logError(r, err)
        message := "the server encountered a problem and could not process your request"
        app.errorResponse(w, r, http.StatusInternalServerError, message)
}</span>

// The invalidAuthenticationTokenResponse() method will return invalid token error
func (app *application) invalidAuthenticationTokenResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("WWW-Authenticate", "Bearer")
        message := "invalid or missing authentication token"
        app.errorResponse(w, r, http.StatusUnauthorized, message)
}</span>

// The authenticationRequiredResponse() method will return 403 authentication required error, that
// is the client needs to register + auth their account to proceed.
func (app *application) authenticationRequiredResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "you must be authenticated to access this resource"
        app.errorResponse(w, r, http.StatusUnauthorized, message)
}</span>

// The inactiveAccountResponse() method will return 401 inactive account error, that is the account
// needs to be activated to proceed.
func (app *application) inactiveAccountResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "your user account must be activated to access this resource"
        app.errorResponse(w, r, http.StatusLocked, message)
}</span>

// The badRequestResponse() method will be used to send a 400 Bad Request status code and
// JSON response to the client.
func (app *application) badRequestResponse(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        app.errorResponse(w, r, http.StatusBadRequest, err.Error())
}</span>

// Note that the errors parameter here has the type map[string]string, which is exactly
// the same as the errors map contained in our Validator type.
func (app *application) failedValidationResponse(w http.ResponseWriter, r *http.Request, errors map[string]string) <span class="cov0" title="0">{
        app.errorResponse(w, r, http.StatusUnprocessableEntity, errors)
}</span>

// The rateLimitExceededResponse() method will return a 429 too many requests error.
func (app *application) rateLimitExceededResponse(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        message := "rate limit exceeded"
        app.errorResponse(w, r, http.StatusTooManyRequests, message)
}</span>

// The editConflictResponse() method will be used to send a 409 Conflict status code and
// JSON response to the client.
func (app *application) editConflictResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "unable to update the record due to an edit conflict, please try again"
        app.errorResponse(w, r, http.StatusConflict, message)
}</span>

// The invalidCredentialsResponse() method will return invalid token credential error
func (app *application) invalidCredentialsResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "invalid authentication credentials"
        app.errorResponse(w, r, http.StatusUnauthorized, message)
}</span>

func (app *application) sessionExpiredResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "session expired or not found. please log in again"
        app.errorResponse(w, r, http.StatusUnauthorized, message)
}</span>

// The notFoundResponse() method will be used to send a 404 Not Found status code and
// JSON response to the client.
func (app *application) notFoundResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "the requested resource could not be found"
        app.errorResponse(w, r, http.StatusNotFound, message)
}</span>

// The notPermittedResponse() method will return 403 not permitted error, that is the account doesn't
// have the necessary permissions to access this resource.
func (app *application) notPermittedResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "your user account doesn't have the necessary permissions to access this resource"
        app.errorResponse(w, r, http.StatusForbidden, message)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "net/http"
)

// healthcheckHandler provides a simple health check endpoint that returns the application status
func (app *application) healthcheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Create health status response
        health := envelope{
                "status":      "available",
                "environment": app.config.env,
                "version":     version,
        }

        // Write successful health check response
        err := app.writeJSON(w, http.StatusOK, health, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
        "github.com/go-chi/chi"
)

var (
        ErrInvalidAuthentication = errors.New("invalid authentication token format")
        ErrNoDataFoundInRedis    = errors.New("no data found in Redis")
)

// Define an envelope type.
type envelope map[string]any

// Define a writeJSON() helper for sending responses. This takes the destination
// http.ResponseWriter, the HTTP status code to send, the data to encode to JSON, and a
// header map containing any additional HTTP headers we want to include in the response.
func (app *application) writeJSON(w http.ResponseWriter, status int, data envelope, headers http.Header) error <span class="cov8" title="1">{
        // Encode the data to JSON, returning the error if there was one.
        js, err := json.MarshalIndent(data, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Append a newline to make it easier to view in terminal applications.
        <span class="cov8" title="1">js = append(js, '\n')
        // At this point, we know that we won't encounter any more errors before writing the
        // response, so it's safe to add any headers that we want to include.
        for key, value := range headers </span><span class="cov0" title="0">{
                w.Header()[key] = value
        }</span>
        // Add the "Content-Type: application/json" header, then write the status code
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _, err = w.Write(js)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (app *application) readJSON(w http.ResponseWriter, r *http.Request, dst any) error <span class="cov0" title="0">{
        // Use http.MaxBytesReader() to limit the size of the request body to 1MB.
        maxBytes := 1_048_576
        r.Body = http.MaxBytesReader(w, r.Body, int64(maxBytes))
        // Initialize the json.Decoder, and call the DisallowUnknownFields() method on it
        // before decoding. This means that if the JSON from the client now includes any
        // field which cannot be mapped to the target destination, the decoder will return
        // an error instead of just ignoring the field.
        dec := json.NewDecoder(r.Body)
        dec.DisallowUnknownFields()
        // Decode the request body to the destination.
        err := dec.Decode(dst)
        err = app.jsonReadAndHandleError(err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Call Decode() again, using a pointer to an empty anonymous struct as the
        // destination. If the request body only contained a single JSON value this will
        // return an io.EOF error. So if we get anything else, we know that there is
        // additional data in the request body and we return our own custom error message.
        <span class="cov0" title="0">err = dec.Decode(&amp;struct{}{})
        if err != io.EOF </span><span class="cov0" title="0">{
                return errors.New("body must only contain a single JSON value")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Retrieve the "id" URL parameter from the current request context, then convert it to
// an integer and return it. If the operation isn't successful, return a nil UUID and an error.
func (app *application) readIDParam(r *http.Request, parameterName string) (int64, error) <span class="cov0" title="0">{
        // We use chi's URLParam method to get our ID parameter from the URL.
        params := chi.URLParam(r, parameterName)
        id, err := strconv.ParseInt(params, 10, 64)
        if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                return 0, errors.New("invalid i-id parameter")
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

// jsonReadAndHandleError() is a helper function that takes an error as a parameter and
// returns a cleaned-up error message. This is used to provide more information in the
// event of a JSON decoding error.
func (app *application) jsonReadAndHandleError(err error) error <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                // Vars to carry our errors
                var syntaxError *json.SyntaxError
                var unmarshalTypeError *json.UnmarshalTypeError
                var invalidUnmarshalError *json.InvalidUnmarshalError
                // Add a new maxBytesError variable.
                var maxBytesError *http.MaxBytesError
                switch </span>{
                case errors.As(err, &amp;syntaxError):<span class="cov0" title="0">
                        return fmt.Errorf("body contains badly-formed JSON (at character %d)", syntaxError.Offset)</span>
                case errors.Is(err, io.ErrUnexpectedEOF):<span class="cov0" title="0">
                        return errors.New("body contains badly-formed JSON")</span>
                case errors.As(err, &amp;unmarshalTypeError):<span class="cov0" title="0">
                        if unmarshalTypeError.Field != "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("body contains incorrect JSON type for field %q", unmarshalTypeError.Field)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("body contains incorrect JSON type (at character %d)", unmarshalTypeError.Offset)</span>
                case errors.Is(err, io.EOF):<span class="cov0" title="0">
                        return errors.New("body must not be empty")</span>
                // If the JSON contains a field which cannot be mapped to the target destination
                // then Decode() will now return an error message in the format "json: unknown
                // field "&lt;name&gt;"". We check for this, extract the field name from the error,
                // and interpolate it into our custom error message. Note that there's an open
                // issue at https://github.com/golang/go/issues/29035 regarding turning this
                // into a distinct error type in the future.
                case strings.HasPrefix(err.Error(), "json: unknown field "):<span class="cov0" title="0">
                        fieldName := strings.TrimPrefix(err.Error(), "json: unknown field ")
                        return fmt.Errorf("body contains unknown key %s", fieldName)</span>
                // Use the errors.As() function to check whether the error has the type
                // *http.MaxBytesError. If it does, then it means the request body exceeded our
                // size limit of 1MB and we return a clear error message.
                case errors.As(err, &amp;maxBytesError):<span class="cov0" title="0">
                        return fmt.Errorf("body must not be larger than %d bytes", maxBytesError.Limit)</span>
                case errors.As(err, &amp;invalidUnmarshalError):<span class="cov0" title="0">
                        panic(err)</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// The background() helper accepts an arbitrary function as a parameter.
// It launches a background goroutine to execute the function.
// The done() method of the WaitGroup is called when the goroutine completes.
func (app *application) background(fn func()) <span class="cov0" title="0">{
        app.wg.Add(1)
        // Launch a background goroutine.
        go func() </span><span class="cov0" title="0">{
                //defer our done()
                defer app.wg.Done()
                // Recover any panic.
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                app.logger.Error(fmt.Sprintf("%s", err))
                        }</span>
                }()
                // Execute the arbitrary function that we passed as the parameter.
                <span class="cov0" title="0">fn()</span>
        }()
}

// aunthenticatorHelper() is a helper function for the authentication middleware
// It takes in a request and returns a user and an error
func (app *application) aunthenticatorHelper(r *http.Request) (*data.User, error) <span class="cov8" title="1">{
        // Retrieve the value of the Authorization header from the request. This will
        authorizationHeader := r.Header.Get("Authorization")
        // If there is no Authorization header found, use the contextSetUser() helper to
        // add the AnonUser to the request context. Then we
        if authorizationHeader == "" </span><span class="cov8" title="1">{
                return data.AnonymousUser, nil
        }</span>
        // Otherwise, we expect the value of the Authorization header to be in the format
        // "Bearer &lt;token&gt;". We try to split this into its constituent parts, and if the
        // header isn't in the expected format we return a 401 Unauthorized response
        // using the invalidAuthenticationTokenResponse() helper
        <span class="cov0" title="0">headerParts := strings.Split(authorizationHeader, " ")
        if len(headerParts) != 2 || headerParts[0] != "Bearer" </span><span class="cov0" title="0">{
                return nil, ErrInvalidAuthentication
        }</span>
        // Extract the actual authentication token from the header parts.
        <span class="cov0" title="0">token := headerParts[1]
        //app.logger.Info("User id Connected", zap.String("Connected ID", token))
        // Validate the token to make sure it is in a sensible format.
        v := validator.New()
        // If the token isn't valid, use the invalidAuthenticationTokenResponse()
        // helper to send a response, rather than the failedValidationResponse() helper
        // that we'd normally use.
        if data.ValidateTokenPlaintext(v, token); !v.Valid() </span><span class="cov0" title="0">{
                return nil, ErrInvalidAuthentication
        }</span>
        // Retrieve the details of the user associated with the authentication token,
        // again calling the invalidAuthenticationTokenResponse() helper if no
        // matching record was found. IMPORTANT: Notice that we are using
        // ScopeAuthentication as the first parameter here.
        <span class="cov0" title="0">user, err := app.models.Users.GetForToken(data.ScopeAuthentication, token)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrGeneralRecordNotFound):<span class="cov0" title="0">
                        return nil, ErrInvalidAuthentication</span>
                default:<span class="cov0" title="0">
                        return nil, ErrInvalidAuthentication</span>
                }
        }
        <span class="cov0" title="0">return user, nil</span>
}

// validateURL() checks if the input string is a valid URL
func validateURL(input string) error <span class="cov0" title="0">{
        parsedURL, err := url.ParseRequestURI(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid URL: %w", err)
        }</span>

        // Further validate URL components
        <span class="cov0" title="0">if parsedURL.Scheme == "" || parsedURL.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("URL must contain both scheme and host")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// The readString() helper returns a string value from the query string, or the provided
// default value if no matching key could be found.
func (app *application) readString(qs url.Values, key string, defaultValue string) string <span class="cov0" title="0">{
        // Extract the value for a given key from the query string. If no key exists this
        // will return the empty string "".
        s := qs.Get(key)
        // If no key exists (or the value is empty) then return the default value.
        if s == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        // Otherwise return the string.
        <span class="cov0" title="0">return s</span>
}

// The readInt() helper reads a string value from the query string and converts it to an
// integer before returning. If no matching key could be found it returns the provided
// default value. If the value couldn't be converted to an integer, then we record an
// error message in the provided Validator instance.
func (app *application) readInt(qs url.Values, key string, defaultValue int, v *validator.Validator) int <span class="cov0" title="0">{
        // Extract the value from the query string.
        s := qs.Get(key)
        // If no key exists (or the value is empty) then return the default value.
        if s == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        // Try to convert the value to an int. If this fails, add an error message to the
        // validator instance and return the default value.
        <span class="cov0" title="0">i, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                v.AddError(key, "must be an integer value")
                return defaultValue
        }</span>
        // Otherwise, return the converted integer value.
        <span class="cov0" title="0">return i</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "database/sql"
        "expvar"
        "flag"
        "fmt"
        "os"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
        "github.com/Blue-Davinci/leadhub-service/internal/database"
        "github.com/Blue-Davinci/leadhub-service/internal/logger"
        "github.com/Blue-Davinci/leadhub-service/internal/mailer"
        "github.com/Blue-Davinci/leadhub-service/internal/vcs"
        _ "github.com/lib/pq"
        "go.uber.org/zap"
)

// a quick variable to hold our version.
var (
        version = vcs.Version()
)

type config struct {
        port int
        env  string
        api  struct {
                name    string
                author  string
                version string
        }
        db struct {
                dsn          string
                maxOpenConns int
                maxIdleConns int
                maxIdleTime  string
        }
        cors struct {
                trustedOrigins []string
        }
        url struct {
                activationURL     string
                authenticationURL string
        }
        smtp struct {
                host     string
                port     int
                username string
                password string
                sender   string
        }
        limiter struct {
                rps     float64
                burst   int
                enabled bool
        }
}

type application struct {
        config config
        logger *zap.Logger
        wg     sync.WaitGroup
        models data.Models
        mailer mailer.Mailer
}

func main() <span class="cov0" title="0">{
        logger, err := logger.InitJSONLogger()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error initializing logger, exiting...")
                return
        }</span>

        // config
        <span class="cov0" title="0">var cfg config
        // Port &amp; env
        flag.IntVar(&amp;cfg.port, "port", 4000, "API server port")
        flag.StringVar(&amp;cfg.env, "env", "development", "Environment (development|staging|production)")
        // Database configuration
        flag.StringVar(&amp;cfg.db.dsn, "db-dsn", os.Getenv("LEADHUB_DB_DSN"), "PostgreSQL DSN")
        flag.IntVar(&amp;cfg.db.maxOpenConns, "db-max-open-conns", 25, "PostgreSQL max open connections")
        flag.IntVar(&amp;cfg.db.maxIdleConns, "db-max-idle-conns", 25, "PostgreSQL max idle connections")
        flag.StringVar(&amp;cfg.db.maxIdleTime, "db-max-idle-time", "15m", "PostgreSQL max connection idle time")
        // api configuration
        flag.StringVar(&amp;cfg.api.name, "api-name", "LeadHUb", "API Name")
        flag.StringVar(&amp;cfg.api.author, "api-author", "Blue-Davinci", "API Author")
        // Our SMTP flags with given defaults.
        flag.StringVar(&amp;cfg.smtp.host, "smtp-host", os.Getenv("LEADHUB_SMTP_HOST"), "SMTP server hostname")
        flag.IntVar(&amp;cfg.smtp.port, "smtp-port", 587, "SMTP server port")
        flag.StringVar(&amp;cfg.smtp.username, "smtp-username", os.Getenv("LEADHUB_SMTP_USERNAME"), "SMTP server username")
        flag.StringVar(&amp;cfg.smtp.password, "smtp-password", os.Getenv("LEADHUB_SMTP_PASSWORD"), "SMTP server password")
        flag.StringVar(&amp;cfg.smtp.sender, "smtp-sender", os.Getenv("LEADHUB_SMTP_SENDER"), "SMTP sender email address")
        // limiter cinfugs
        flag.Float64Var(&amp;cfg.limiter.rps, "limiter-rps", 5, "Rate limiter maximum requests per second")
        flag.IntVar(&amp;cfg.limiter.burst, "limiter-burst", 10, "Rate limiter maximum burst")
        flag.BoolVar(&amp;cfg.limiter.enabled, "limiter-enabled", true, "Enable rate limiter")
        // URL configuration
        flag.StringVar(&amp;cfg.url.activationURL, "activation-url", "http://localhost:4000/v1/api/activated/token=", "Activation URL for user registration")
        flag.StringVar(&amp;cfg.url.authenticationURL, "authentication-url", "http://localhost:4000/v1/api/authentication", "Authentication URL for user login")
        // CORS configuration
        flag.Func("cors-trusted-origins", "Trusted CORS origins (space separated)", func(val string) error </span><span class="cov0" title="0">{
                cfg.cors.trustedOrigins = strings.Fields(val)
                return nil

        }</span>)
        // Parse the flags
        <span class="cov0" title="0">flag.Parse()

        // Construct DSN from individual components if not provided directly
        if cfg.db.dsn == "" </span><span class="cov0" title="0">{
                dbUser := getEnvDefault("DB_USER", "leadhub")
                dbPassword := getEnvDefault("DB_PASSWORD", "test")
                dbHost := getEnvDefault("DB_HOST", "localhost")
                dbPort := getEnvDefault("DB_PORT", "5432")
                dbName := getEnvDefault("DB_NAME", "leadhub")
                dbSSLMode := getEnvDefault("DB_SSLMODE", "disable")

                cfg.db.dsn = fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=%s",
                        dbUser, dbPassword, dbHost, dbPort, dbName, dbSSLMode)

                logger.Info("Constructed DSN from individual components",
                        zap.String("host", dbHost),
                        zap.String("port", dbPort),
                        zap.String("database", dbName))
        }</span>

        // Load additional configuration from environment variables
        <span class="cov0" title="0">loadConfig(&amp;cfg)
        // create our connection pull
        db, err := openDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err.Error(), zap.String("dsn", cfg.db.dsn))
        }</span>
        // Init our exp metrics variables for server metrics.
        <span class="cov0" title="0">publishMetrics()
        // instantiate the application struct for dependency injection
        app := &amp;application{
                config: cfg,
                logger: logger,
                models: data.NewModels(db),
                mailer: mailer.New(cfg.smtp.host, cfg.smtp.port, cfg.smtp.username, cfg.smtp.password, cfg.smtp.sender),
        }
        // Print the version information
        logger.Info("Starting LeadHub Service",
                zap.String("version", version),
                zap.String("env", app.config.env),
                zap.Int("port", app.config.port),
        )
        err = app.server()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error while starting server.", zap.String("error", err.Error()))
        }</span>
}

// openDB() opens a new database connection using the provided configuration.
// It returns a pointer to the sql.DB connection pool and an error value.
func openDB(cfg config) (*database.Queries, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", cfg.db.dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.db.maxOpenConns)
        db.SetMaxIdleConns(cfg.db.maxIdleConns)
        duration, err := time.ParseDuration(cfg.db.maxIdleTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetConnMaxIdleTime(duration)
        // Use ping to establish new conncetions
        err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">queries := database.New(db)
        return queries, nil</span>
}

// publishMetrics sets up the expvar variables for the application
// It sets the version, the number of active goroutines, and the current Unix timestamp.
func publishMetrics() <span class="cov0" title="0">{
        expvar.NewString("version").Set(version)
        // Publish the number of active goroutines.
        expvar.Publish("goroutines", expvar.Func(func() any </span><span class="cov0" title="0">{
                return runtime.NumGoroutine()
        }</span>))
        // Publish the current Unix timestamp.
        <span class="cov0" title="0">expvar.Publish("timestamp", expvar.Func(func() any </span><span class="cov0" title="0">{
                return time.Now().Unix()
        }</span>))
}

// loadConfig loads additional configuration values from environment variables
func loadConfig(cfg *config) <span class="cov0" title="0">{
        // Set API configuration
        cfg.api.name = getEnvDefault("LEADHUB_API_NAME", "LEADHUB API")
        cfg.api.author = getEnvDefault("LEADHUB_API_AUTHOR", "Blue-Davinci")
        cfg.api.version = version

        // Set CORS trusted origins (comma-separated)
        originsStr := getEnvDefault("LEADHUB_CORS_TRUSTED_ORIGINS", "http://localhost:3000,http://localhost:8080")
        if originsStr != "" </span><span class="cov0" title="0">{
                cfg.cors.trustedOrigins = strings.Split(originsStr, ",")
                // Trim spaces from each origin
                for i, origin := range cfg.cors.trustedOrigins </span><span class="cov0" title="0">{
                        cfg.cors.trustedOrigins[i] = strings.TrimSpace(origin)
                }</span>
        }
}

// getEnvDefault gets an environment variable with a default fallback
func getEnvDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "errors"
        "expvar"
        "fmt"
        "net/http"
        "strconv"
        "sync"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
        "github.com/felixge/httpsnoop"
        "github.com/tomasen/realip"
        "golang.org/x/time/rate"
)

func (app *application) recoverPanic(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Create a deferred function (which will always be run in the event of a panic
                // as Go unwinds the stack).
                defer func() </span><span class="cov8" title="1">{
                        // Use the builtin recover function to check if there has been a panic or
                        // not.
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                // If there was a panic, set a "Connection: close" header on the
                                // response. This acts as a trigger to make Go's HTTP server
                                // automatically close the current connection after a response has been
                                // sent.
                                w.Header().Set("Connection", "close")
                                // The value returned by recover() has the type any, so we use
                                // fmt.Errorf() to normalize it into an error and call our
                                // serverErrorResponse() helper. In turn, this will log the error using
                                // our custom Logger type at the ERROR level and send the client a 500
                                // Internal Server Error response.
                                app.serverErrorResponse(w, r, fmt.Errorf("%s", err))
                        }</span>
                }()
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func (app *application) authenticate(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Add the "Vary: Authorization" header to the response. This indicates to any
                // caches that the response may vary based on the value of the Authorization
                // header in the request.
                w.Header().Add("Vary", "Authorization")
                // Retrieve the value of the Authorization header from the request. This will
                // return the empty string "" if there is no such header found.
                user, err := app.aunthenticatorHelper(r)
                if user == data.AnonymousUser </span><span class="cov8" title="1">{
                        r = app.contextSetUser(r, data.AnonymousUser)
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, ErrInvalidAuthentication):<span class="cov0" title="0">
                                app.invalidAuthenticationTokenResponse(w, r)</span>
                        case errors.Is(err, data.ErrGeneralRecordNotFound):<span class="cov0" title="0">
                                app.invalidAuthenticationTokenResponse(w, r)</span>
                        default:<span class="cov0" title="0">
                                app.serverErrorResponse(w, r, err)</span>
                        }
                        <span class="cov0" title="0">return</span>
                }
                // Call the contextSetUser() helper to add the user information to the request
                // context.
                <span class="cov0" title="0">r = app.contextSetUser(r, user)
                // Call the next handler in the chain.
                next.ServeHTTP(w, r)</span>
        })
}

// Create a new requireAuthenticatedUser() middleware to check that a user is not
// anonymous.
func (app *application) requireAuthenticatedUser(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Use the contextGetUser() helper to retrieve the user
                // information from the request context.
                user := app.contextGetUser(r)
                // If the user is anonymous, then call the authenticationRequiredResponse() to
                // inform the client that they should authenticate before trying again.
                if user.IsAnonymous() </span><span class="cov0" title="0">{
                        app.authenticationRequiredResponse(w, r)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// Checks that a user is both authenticated and activated.
func (app *application) requireActivatedUser(next http.Handler) http.Handler <span class="cov0" title="0">{
        // Rather than returning this http.HandlerFunc we assign it to the variable fn.
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                user := app.contextGetUser(r)
                // If the user is not activated, use the inactiveAccountResponse() helper to
                // inform them that they need to activate their account.
                if !user.Activated </span><span class="cov0" title="0">{
                        app.inactiveAccountResponse(w, r)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// The rateLimit() middleware will be used to rate limit the number of requests that a
// client can make to certain routes within a given time window.
func (app *application) rateLimit(next http.Handler) http.Handler <span class="cov8" title="1">{
        // Define a client struct to hold the rate limiter and last seen time for each
        // client.
        type client struct {
                limiter  *rate.Limiter
                lastSeen time.Time
        }

        // Declare a mutex and a map to hold the clients' IP addresses and rate limiters.
        var (
                mu      sync.Mutex
                clients = make(map[string]*client)
        )
        // Launch a background goroutine which removes old entries from the clients map once
        // every minute.
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        time.Sleep(time.Minute)
                        // Lock the mutex to prevent any rate limiter checks from happening while
                        // the cleanup is taking place.
                        mu.Lock()
                        // Loop through all clients. If they haven't been seen within the last three
                        // minutes, delete the corresponding entry from the map.
                        for ip, client := range clients </span><span class="cov0" title="0">{
                                if time.Since(client.lastSeen) &gt; 3*time.Minute </span><span class="cov0" title="0">{
                                        delete(clients, ip)
                                }</span>
                        }
                        // Importantly, unlock the mutex when the cleanup is complete.
                        <span class="cov0" title="0">mu.Unlock()</span>
                }
        }()

        <span class="cov8" title="1">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Only carry out the check if rate limiting is enabled.
                if app.config.limiter.enabled </span><span class="cov8" title="1">{
                        // Extract the client's IP address from the request.
                        ip := realip.FromRequest(r)
                        // Lock the mutex to prevent this code from being executed concurrently.
                        mu.Lock()
                        // Check to see if the IP address already exists in the map. If it doesn't, then
                        // initialize a new rate limiter and add the IP address and limiter to the map.
                        if _, found := clients[ip]; !found </span><span class="cov8" title="1">{
                                clients[ip] = &amp;client{
                                        // Use the requests-per-second and burst values from the config struct.
                                        limiter: rate.NewLimiter(rate.Limit(app.config.limiter.rps), app.config.limiter.burst),
                                }
                        }</span>
                        // Update the last seen time for the client.
                        <span class="cov8" title="1">clients[ip].lastSeen = time.Now()

                        // Call the Allow() method on the rate limiter for the current IP address. If
                        // the request isn't allowed, unlock the mutex and send a 429 Too Many Requests
                        // response, just like before.
                        if !clients[ip].limiter.Allow() </span><span class="cov8" title="1">{
                                mu.Unlock()
                                app.rateLimitExceededResponse(w, r)
                                return
                        }</span>
                        // unlock the mutex before calling the next handler in the
                        // chain
                        <span class="cov8" title="1">mu.Unlock()</span>
                }
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// The metrics() middleware will be used to collect and expose various metrics about the
// API server, such as the total number of requests received, the total number of
func (app *application) metrics(next http.Handler) http.Handler <span class="cov8" title="1">{
        // Initialize the new expvar variables when the middleware chain is first built.
        totalRequestsReceived := expvar.NewInt("total_requests_received")
        totalResponsesSent := expvar.NewInt("total_responses_sent")
        totalProcessingTimeMicroseconds := expvar.NewInt("total_processing_time_Î¼s")
        totalResponsesSentByStatus := expvar.NewMap("total_responses_sent_by_status")

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Increment the number of requests received by 1.
                totalRequestsReceived.Add(1)

                // Use httpsnoop to capture metrics while passing along the original response writer.
                metrics := httpsnoop.CaptureMetrics(next, w, r)

                // Increment the total responses sent.
                totalResponsesSent.Add(1)
                // Increment the processing time.
                totalProcessingTimeMicroseconds.Add(metrics.Duration.Microseconds())
                // Increment the count for the response status code.
                totalResponsesSentByStatus.Add(strconv.Itoa(metrics.Code), 1)
        }</span>)
}

// The requirePermission() middleware will be used to check that the authenticated user
// has the required permission to access a specific route.
func (app *application) requirePermission(code string) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Retrieve the user from the request context.
                        user := app.contextGetUser(r)
                        // Get the slice of permissions for the user.
                        permissions, err := app.models.Permissions.GetAllPermissionsForUser(user.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                app.serverErrorResponse(w, r, err)
                                return
                        }</span>
                        // Check if the slice includes the required permission. If it doesn't, then
                        // return a 403 Forbidden response.
                        <span class="cov0" title="0">if !permissions.Include(code) </span><span class="cov0" title="0">{
                                app.notPermittedResponse(w, r)
                                return
                        }</span>
                        // Otherwise they have the required permission so we call the next handler in
                        // the chain.
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "expvar"
        "net/http"

        "github.com/go-chi/chi"
        "github.com/go-chi/cors"
        "github.com/justinas/alice"
)

func (app *application) routes() http.Handler <span class="cov0" title="0">{
        router := chi.NewRouter()
        router.Use(cors.Handler(cors.Options{
                AllowedOrigins:   app.config.cors.trustedOrigins,
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "PATCH"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
                ExposedHeaders:   []string{"link"},
                AllowCredentials: false,
                MaxAge:           300, // Maximum value not ignored by any of major browsers
        }))
        //Use alice to make a global middleware chain.
        globalMiddleware := alice.New(app.metrics, app.recoverPanic, app.rateLimit, app.authenticate).Then
        // Dynamic Middleware, these will apply to only select routes
        dynamicMiddleware := alice.New(app.requireAuthenticatedUser, app.requireActivatedUser)
        // Permission Middleware, this will apply to specific routes that are capped by the permissions
        adminPermissionMiddleware := alice.New(app.requirePermission("admin:write"))

        // Apply the global middleware to the router
        router.Use(globalMiddleware)

        // Make our categorized routes
        v1Router := chi.NewRouter()

        v1Router.Mount("/", app.generalRoutes())
        v1Router.Mount("/api", app.userRoutes())
        v1Router.With(dynamicMiddleware.Then).Mount("/tenants", app.tenantRoutes(&amp;adminPermissionMiddleware))
        v1Router.With(dynamicMiddleware.Then).Mount("/trade_leads", app.tradeLeadsRoutes(&amp;adminPermissionMiddleware))

        // Moount the v1Router to the main base router
        router.Mount("/v1", v1Router)
        return router
}</span>

// generalRoutes() provides a router for the general routes.
// Mounted rirectly after our version url. They contaon sanity and
// health checks. Probably add other AOB's here.
func (app *application) generalRoutes() chi.Router <span class="cov0" title="0">{
        generalRoutes := chi.NewRouter()
        // /debug/vars : for expvar, wrapping it in a handler func for assertion otherwise it complains
        generalRoutes.Get("/debug/vars", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                expvar.Handler().ServeHTTP(w, r)
        }</span>)
        <span class="cov0" title="0">generalRoutes.Get("/health", app.healthcheckHandler)
        return generalRoutes</span>
}

// userRoutes() is a method that returns a chi.Router that contains all the routes for the users
func (app *application) userRoutes() chi.Router <span class="cov0" title="0">{
        userRoutes := chi.NewRouter()
        userRoutes.Post("/", app.registerUserHandler)
        userRoutes.Post("/authentication", app.createAuthenticationApiKeyHandler)
        // /activation : for activating accounts
        userRoutes.Put("/activated", app.activateUserHandler)
        return userRoutes
}</span>

// tenantRoutes() is a method that returns a chi.Router that contains all the routes for the tenants
// This is a placeholder for tenant-related routes, which can be expanded as needed.
func (app *application) tenantRoutes(adminPermissionMiddleware *alice.Chain) chi.Router <span class="cov0" title="0">{
        tenantRoutes := chi.NewRouter()
        // /tenants/{id} : for getting a tenant by ID
        tenantRoutes.Get("/", app.getTenantByIDHandler)

        // admin routes
        tenantRoutes.With(adminPermissionMiddleware.Then).Post("/admin", app.createTenantHandler)
        tenantRoutes.With(adminPermissionMiddleware.Then).Get("/admin", app.adminGetAllTenantsHandler)
        tenantRoutes.With(adminPermissionMiddleware.Then).Patch("/admin/{tenantID:[0-9]+}/{versionID:[0-9]+}", app.updateTenantHandler)
        return tenantRoutes
}</span>

// tradeLeadsRoutes() is a method that returns a chi.Router that contains all the routes for the trade leads
func (app *application) tradeLeadsRoutes(adminPermissionMiddleware *alice.Chain) chi.Router <span class="cov0" title="0">{
        tradeLeadsRoutes := chi.NewRouter()
        // /trade_leads : for creating a new trade lead
        tradeLeadsRoutes.Post("/", app.createTradeLeadHandler)
        tradeLeadsRoutes.Get("/", app.getAllLeadsByTenantIDHandler)

        // admin routes
        tradeLeadsRoutes.With(adminPermissionMiddleware.Then).Get("/admin", app.adminGetAllTradeLeadsHandler)
        // pathc adminUpdateTradeLeadStatusHandler
        tradeLeadsRoutes.With(adminPermissionMiddleware.Then).Patch("/admin/{leadID:[0-9]+}/{versionID:[0-9]+}", app.adminUpdateTradeLeadStatusHandler)
        // get trade lead stats
        tradeLeadsRoutes.With(adminPermissionMiddleware.Then).Get("/admin/stats", app.adminGetTradeLeadStatsHandler)
        return tradeLeadsRoutes
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "go.uber.org/zap"
)

func (app *application) server() error <span class="cov0" title="0">{
        // declare our http server
        srv := &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", app.config.port),
                Handler:      app.routes(),
                IdleTimeout:  time.Minute,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 60 * time.Second,
        }
        // make a channel to listen for shutdown signals
        shutdownChan := make(chan error)
        // start a background routine, this will listen to any shutdown signals
        go func() </span><span class="cov0" title="0">{
                // make a quit channel
                quit := make(chan os.Signal, 1)
                // listen for the SIGINT and SIGTERM signals
                signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
                // read signal from the quit channel and will wait till there is an actual signal
                s := &lt;-quit
                // printout the signal details
                app.logger.Info("shutting down server", zap.String("signal", s.String()))
                // make a 20sec context
                ctx, cancel := context.WithTimeout(context.Background(), 20*time.Second)
                defer cancel()
                err := srv.Shutdown(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        shutdownChan &lt;- err
                }</span>
                <span class="cov0" title="0">app.logger.Info("completing background tasks...", zap.String("addr", srv.Addr))
                // wait for any background tasks to complete
                app.wg.Wait()
                // Call Shutdown() on our server, passing in the context we just made.
                shutdownChan &lt;- srv.Shutdown(ctx)</span>
        }()
        // start the server printing out our main settings
        <span class="cov0" title="0">app.logger.Info("starting server", zap.String("addr", srv.Addr), zap.String("env", app.config.env))
        if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Otherwise, we wait to receive the return value from Shutdown() on the
        // shutdownError channel. If return value is an error, we know that there was a
        // problem with the graceful shutdown and we return the error.
        <span class="cov0" title="0">err := &lt;-shutdownChan
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Exiting....
        <span class="cov0" title="0">app.logger.Info("stopped server", zap.String("addr", srv.Addr))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "errors"
        "net/http"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
)

// The getTenantByIDHandler() method will handle requests to retrieve a tenant by its ID.
// This is user specific, so we will extract their user information from the request context
// and use it to fetch the tenant details from the database.
// It will return a JSON response with the tenant details or an error if the tenant is not found.
func (app *application) getTenantByIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract the user from the request context.
        user := app.contextGetUser(r)

        // Fetch the tenant details from the database using the user ID and tenant ID.
        tenant, err := app.models.Tenants.GetTenantByID(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write the tenant details as a JSON response.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"tenant": tenant}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// adminGetAllTenantsHandler() is a method that will handle requests to retrieve all tenants.
// It supports pagination and name aearching.
func (app *application) adminGetAllTenantsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // make a struct to hold what we would want from the queries
        var input struct {
                Name string
                data.Filters
        }
        v := validator.New()
        // Call r.URL.Query() to get the url.Values map containing the query string data.
        qs := r.URL.Query()
        // get our parameters
        input.Name = app.readString(qs, "name", "")
        //get the page &amp; pagesizes as ints and set to the embedded struct
        input.Filters.Page = app.readInt(qs, "page", 1, v)
        input.Filters.PageSize = app.readInt(qs, "page_size", 20, v)
        // We don't use any sort for this endpoint
        input.Filters.Sort = app.readString(qs, "", "")
        // None of the sort values are supported for this endpoint
        input.Filters.SortSafelist = []string{"", ""}
        // Perform validation
        if data.ValidateFilters(v, input.Filters); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // Call the AdminGetAllTenants method to retrieve the tenants from the database.
        <span class="cov0" title="0">tenants, metadata, err := app.models.Tenants.AdminGetAllTenants(input.Name, input.Filters)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write the tenants and metadata as a JSON response.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"tenants": tenants, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// The CreateTenant() is an ADMIN method that will handle requests to create a new tenant.
// It will extract the tenant details from the request body, validate them,
// and then create the tenant in the database.
func (app *application) createTenantHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                Name         string `json:"name"`
                ContactEmail string `json:"contact_email"`
                Description  string `json:"description"`
        }
        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // create a new tenant struct
        <span class="cov0" title="0">tenant := &amp;data.Tenant{
                Name:         input.Name,
                ContactEmail: input.ContactEmail,
                Description:  input.Description,
        }

        // Initialize a new Validator.
        v := validator.New()
        if data.ValidateTenant(v, tenant); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // Create the tenant in the database.
        <span class="cov0" title="0">if err := app.models.Tenants.CreateTenant(tenant); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrTenantAlreadyExists:<span class="cov0" title="0">
                        v.AddError("name", "tenant with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write a JSON response with the created tenant details.
        <span class="cov0" title="0">err := app.writeJSON(w, http.StatusCreated, envelope{"tenant": tenant}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// updateTenantHandler() is a method that will handle requests to update an existing tenant.
func (app *application) updateTenantHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // read tenant id from URL parameters
        tenantID, err := app.readIDParam(r, "tenantID")
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // read versionID from URL parameters
        <span class="cov0" title="0">versionID, err := app.readIDParam(r, "versionID")
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // validate
        <span class="cov0" title="0">v := validator.New()
        // validate the tenant ID
        if data.ValidateURLID(v, tenantID, "id"); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // make an input struct to hold the tenant details
        <span class="cov0" title="0">var input struct {
                Name         *string `json:"name"`
                ContactEmail *string `json:"contact_email"`
                Description  *string `json:"description"`
        }
        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // get the tenant by ID
        <span class="cov0" title="0">tenant, err := app.models.Tenants.GetTenantByID(tenantID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // check which fields are being updated
        <span class="cov0" title="0">if input.Name != nil </span><span class="cov0" title="0">{
                tenant.Name = *input.Name
        }</span>
        <span class="cov0" title="0">if input.ContactEmail != nil </span><span class="cov0" title="0">{
                tenant.ContactEmail = *input.ContactEmail
        }</span>
        <span class="cov0" title="0">if input.Description != nil </span><span class="cov0" title="0">{
                tenant.Description = *input.Description
        }</span>
        // Validate the updated tenant details.
        <span class="cov0" title="0">if data.ValidateTenant(v, tenant); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // Update the tenant in the database.
        // Validate versionID can be safely converted to int32
        <span class="cov0" title="0">if versionID &gt; 2147483647 || versionID &lt; -2147483648 </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, errors.New("version ID out of range"))
                return
        }</span>
        <span class="cov0" title="0">if err := app.models.Tenants.UpdateTenant(tenant, int32(versionID)); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                case err == data.ErrTenantAlreadyExists:<span class="cov0" title="0">
                        v.AddError("name", "tenant with this name already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write a JSON response with the updated tenant details.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"tenant": tenant}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "errors"
        "net/http"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
        "github.com/shopspring/decimal"
        "go.uber.org/zap"
)

func (app *application) createTradeLeadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // input struct
        var input struct {
                Title       string          `json:"title"`
                Description string          `json:"description"`
                Value       decimal.Decimal `json:"value"`
        }
        // read the input from the request body
        if err := app.readJSON(w, r, &amp;input); err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // make a new TradeLead struct
        <span class="cov0" title="0">lead := &amp;data.TradeLead{
                Title:       input.Title,
                Description: input.Description,
                Value:       input.Value,
        }
        // validate the input
        v := validator.New()
        if data.ValidateTradeLead(v, lead); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // create the trade lead in the database
        // we use the user's tenant ID from the context to only create leads for the tenant they belong to
        <span class="cov0" title="0">if err := app.models.TradeLeads.CreateTradeLead(app.contextGetUser(r).TenantID, lead); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrInvalidTenantReference:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                case err == data.ErrInvalidTradeLeadStatus:<span class="cov0" title="0">
                        app.badRequestResponse(w, r, err)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">err := app.writeJSON(w, http.StatusCreated, envelope{"trade_lead": lead}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// getAllLeadsByTenantIDHandler() is a method that will handle requests to get all trade leads for a specific tenant.
func (app *application) getAllLeadsByTenantIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // make a struct to hold what we would want from the queries
        var input struct {
                Name string
                data.Filters
        }
        v := validator.New()
        // Call r.URL.Query() to get the url.Values map containing the query string data.
        qs := r.URL.Query()
        // get our parameters
        input.Name = app.readString(qs, "name", "")
        //get the page &amp; pagesizes as ints and set to the embedded struct
        input.Filters.Page = app.readInt(qs, "page", 1, v)
        input.Filters.PageSize = app.readInt(qs, "page_size", 20, v)
        // We don't use any sort for this endpoint
        input.Filters.Sort = app.readString(qs, "", "")
        // None of the sort values are supported for this endpoint
        input.Filters.SortSafelist = []string{"", ""}
        // Perform validation
        if data.ValidateFilters(v, input.Filters); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // Call the GetAllLeadsByTenantID method to retrieve the trade leads from the database.
        <span class="cov0" title="0">leads, metadata, err := app.models.TradeLeads.GetAllLeadsByTenantID(app.contextGetUser(r).TenantID, input.Name, input.Filters)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write the trade leads and metadata as a JSON response.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"trade_leads": leads, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// adminGetAllTradeLeadsHandler() is a method that will handle requests to retrieve all trade leads.
func (app *application) adminGetAllTradeLeadsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // make a struct to hold what we would want from the queries
        var input struct {
                Name string
                data.Filters
        }
        v := validator.New()
        // Call r.URL.Query() to get the url.Values map containing the query string data.
        qs := r.URL.Query()
        // get our parameters
        input.Name = app.readString(qs, "name", "")
        //get the page &amp; pagesizes as ints and set to the embedded struct
        input.Filters.Page = app.readInt(qs, "page", 1, v)
        input.Filters.PageSize = app.readInt(qs, "page_size", 20, v)
        // We don't use any sort for this endpoint
        input.Filters.Sort = app.readString(qs, "", "")
        // None of the sort values are supported for this endpoint
        input.Filters.SortSafelist = []string{"", ""}
        // Perform validation
        if data.ValidateFilters(v, input.Filters); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // Call the AdminGetAllTradeLeads method to retrieve the trade leads from the database.
        <span class="cov0" title="0">leads, metadata, err := app.models.TradeLeads.AdminGetAllTradeLeads(input.Name, input.Filters)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write the trade leads and metadata as a JSON response.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"trade_leads": leads, "metadata": metadata}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// adminGetTradeLeadStatsHandler() is a method that will handle requests to retrieve trade lead statistics.
func (app *application) adminGetTradeLeadStatsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Call the AdminGetTradeLeadStats method to retrieve the trade lead statistics from the database.
        stats, err := app.models.TradeLeads.AdminGetTradeLeadStats()
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write the trade lead statistics as a JSON response.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"trade_lead_stats": stats}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// adminUpdateTradeLeadStatusHandler() is a method that will handle requests to update the status of a trade lead.
func (app *application) adminUpdateTradeLeadStatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // get trade ID from the URL parameters
        leadID, err := app.readIDParam(r, "leadID")
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // get version ID from the URL parameters
        <span class="cov0" title="0">versionID, err := app.readIDParam(r, "versionID")
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        <span class="cov0" title="0">app.logger.Info("Version and Lead ID", zap.Int64("leadID", leadID), zap.Int64("versionID", versionID))
        // check if the lead exists
        lead, err := app.models.TradeLeads.GetTradeLeadByID(leadID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // let us update the lead status
        // Validate versionID can be safely converted to int32 (range: -2,147,483,648 to 2,147,483,647)
        <span class="cov0" title="0">if versionID &gt; 2147483647 || versionID &lt; -2147483648 </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, errors.New("version ID out of range"))
                return
        }</span>
        <span class="cov0" title="0">err = app.models.TradeLeads.AdminUpdateTradeLeadStatus(leadID, int32(versionID), lead)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err == data.ErrInvalidTradeLeadStatus:<span class="cov0" title="0">
                        app.badRequestResponse(w, r, err)</span>
                case err == data.ErrGeneralRecordNotFound:<span class="cov0" title="0">
                        app.notFoundResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // Write a JSON response with the updated trade lead details.
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusOK, envelope{"trade_lead": lead}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "errors"
        "net/http"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/validator"
        "go.uber.org/zap"

        "github.com/Blue-Davinci/leadhub-service/internal/data"
)

func (app *application) registerUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                TenantID int64  `json:"tenant_id"`
                Name     string `json:"name"`
                Email    string `json:"email"`
                Password string `json:"password"`
        }
        err := app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // lets make a new user from the response input
        <span class="cov0" title="0">user := &amp;data.User{
                TenantID:  input.TenantID,
                Name:      input.Name,
                Email:     input.Email,
                Activated: false,
        }
        // lets set the password for the user by using the Set method from the password struct
        err = user.Password.Set(input.Password)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>
        // Perform validation on the user struct before saving the new user
        <span class="cov0" title="0">v := validator.New()
        if data.ValidateUser(v, user); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>

        // insert our user to the DB
        <span class="cov0" title="0">err = app.models.Users.Insert(user)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrDuplicateEmail):<span class="cov0" title="0">
                        v.AddError("email", "a user with this email address already exists")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                case errors.Is(err, data.ErrInvalidTenantID):<span class="cov0" title="0">
                        v.AddError("tenant_id", "the specified tenant does not exist")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }

                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">app.logger.Info("registering a new user", zap.String("email", user.Email), zap.Int64("tenant_id", user.TenantID))
        // After the user record has been created in the database, generate a new activation
        // token for the user.
        token, err := app.models.Tokens.New(user.ID, 3*24*time.Hour, data.ScopeActivation)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">app.background(func() </span><span class="cov0" title="0">{
                data := map[string]any{
                        "activationURL":   app.config.url.activationURL + token.Plaintext,
                        "activationToken": token.Plaintext,
                        "userID":          user.ID,
                }
                // Send the welcome email, passing in the map above as dynamic data.
                err = app.mailer.Send(user.Email, "user_welcome.tmpl", data)
                if err != nil </span><span class="cov0" title="0">{
                        app.logger.Error("failed to send welcome email", zap.String("email", user.Email), zap.Error(err))
                }</span>
        })

        //write our 202 response back to the user and check for any errors
        <span class="cov0" title="0">err = app.writeJSON(w, http.StatusAccepted, envelope{"user": user}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}

// activateUserHandler() Handles activating a user. Inactive users cannot perform a multitude
// of functions. This handler accepts a JSON request containing a plaintext activation token
// and activates the user associated with the token &amp; the activate scope if that token exists.
func (app *application) activateUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse the plaintext activation token from the request body.
        var input struct {
                TokenPlaintext string `json:"token"`
        }
        err := app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // Validate the plaintext token provided by the client.
        <span class="cov0" title="0">v := validator.New()
        if data.ValidateTokenPlaintext(v, input.TokenPlaintext); !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // Retrieve the details of the user associated with the token using the
        // GetForToken() method. If no matching record is found, then we let the
        // client know that the token they provided is not valid.
        <span class="cov0" title="0">user, err := app.models.Users.GetForToken(data.ScopeActivation, input.TokenPlaintext)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrGeneralRecordNotFound):<span class="cov0" title="0">
                        v.AddError("token", "invalid or expired activation token")
                        app.failedValidationResponse(w, r, v.Errors)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">app.logger.Info("User Version: ", zap.Int("Version", int(user.Version)))
        // Update the user's activation status.
        user.Activated = true
        // Save the updated user record in our database, checking for any edit conflicts in
        // the same way that we did for our movie records.
        err = app.models.Users.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, data.ErrGeneralEditConflict):<span class="cov0" title="0">
                        app.editConflictResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // If everything went successfully, then we delete all activation tokens for the
        // user.
        <span class="cov0" title="0">err = app.models.Tokens.DeleteAllForUser(data.ScopeActivation, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>
        // Succesful, so we send an email for a succesful activation
        <span class="cov0" title="0">app.background(func() </span><span class="cov0" title="0">{
                // As there are now multiple pieces of data that we want to pass to our email
                // templates, we create a map to act as a 'holding structure' for the data. This
                // contains the plaintext version of the activation token for the user, along
                // with their ID.
                data := map[string]any{
                        "loginURL": app.config.url.authenticationURL,
                        "userName": user.Name,
                }
                // Send the welcome email, passing in the map above as dynamic data.
                err = app.mailer.Send(user.Email, "user_succesful_activation.tmpl", data)
                if err != nil </span><span class="cov0" title="0">{
                        app.logger.Error("Error sending welcome email", zap.String("email", user.Email), zap.Error(err))
                }</span>
        })
        // minimize data we send back to the client
        <span class="cov0" title="0">newUser := data.UserSubInfo{
                Name:      user.Name,
                Email:     user.Email,
                CreatedAt: user.CreatedAt,
        }
        // Send the updated user details to the client in a JSON response.
        err = app.writeJSON(w, http.StatusAccepted, envelope{"user": newUser}, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>

}

func (app *application) createAuthenticationApiKeyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }
        //read the data from the request
        err := app.readJSON(w, r, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                app.badRequestResponse(w, r, err)
                return
        }</span>
        // validate the user's password &amp; email
        <span class="cov0" title="0">v := validator.New()
        data.ValidateEmail(v, input.Email)
        data.ValidatePasswordPlaintext(v, input.Password)
        if !v.Valid() </span><span class="cov0" title="0">{
                app.failedValidationResponse(w, r, v.Errors)
                return
        }</span>
        // get the user from the database
        <span class="cov0" title="0">user, err := app.models.Users.GetByEmail(input.Email)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                // if the user is not found, we return an invalid credentials response
                case errors.Is(err, data.ErrGeneralRecordNotFound):<span class="cov0" title="0">
                        app.invalidCredentialsResponse(w, r)</span>
                default:<span class="cov0" title="0">
                        // otherwsie return a 500 internal server error
                        app.serverErrorResponse(w, r, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        // check if the password matches
        <span class="cov0" title="0">match, err := user.Password.Matches(input.Password)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>
        // if password doesn't match then we shout
        <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                app.invalidCredentialsResponse(w, r)
                return
        }</span>
        // Otherwise, if the password is correct, we generate a new api_key with a 72-hour
        // expiry time and the scope 'authentication', saving it to the DB
        <span class="cov0" title="0">bearer_token, err := app.models.Tokens.New(user.ID, 72*time.Hour, data.ScopeAuthentication)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
                return
        }</span>
        // make a user sub info
        <span class="cov0" title="0">userSubInfo := data.UserSubInfo{
                Name:      user.Name,
                Email:     user.Email,
                CreatedAt: user.CreatedAt,
        }
        // Encode the apikey to json and send it to the user with a 201 Created status code
        err = app.writeJSON(w, http.StatusCreated, envelope{
                "api_key": bearer_token,
                "user":    userSubInfo,
        }, nil)
        if err != nil </span><span class="cov0" title="0">{
                app.serverErrorResponse(w, r, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package data

import (
        "math"
        "strings"

        "github.com/Blue-Davinci/leadhub-service/internal/validator"
)

// Define a new Metadata struct for holding the pagination metadata.
type Metadata struct {
        CurrentPage  int `json:"current_page,omitempty"`
        PageSize     int `json:"page_size,omitempty"`
        FirstPage    int `json:"first_page,omitempty"`
        LastPage     int `json:"last_page,omitempty"`
        TotalRecords int `json:"total_records,omitempty"`
}

// Add a SortSafelist field to hold the supported sort values.
type Filters struct {
        Page         int
        PageSize     int
        Sort         string
        SortSafelist []string
}

func ValidateFilters(v *validator.Validator, f Filters) <span class="cov0" title="0">{
        // Check that the page and page_size parameters contain sensible values.
        v.Check(f.Page &gt; 0, "page", "must be greater than zero")
        v.Check(f.Page &lt;= 10_000_000, "page", "must be a maximum of 10 million")
        v.Check(f.PageSize &gt; 0, "page_size", "must be greater than zero")
        v.Check(f.PageSize &lt;= 100, "page_size", "must be a maximum of 100")
        // Check that the sort parameter matches a value in the safelist.
        v.Check(validator.PermittedValue(f.Sort, f.SortSafelist...), "sort", "invalid sort value")
}</span>

// Check that the client-provided Sort field matches one of the entries in our safelist
// and if it does, extract the column name from the Sort field by stripping the leading
// hyphen character (if one exists).
func (f Filters) sortColumn() string <span class="cov0" title="0">{
        for _, safeValue := range f.SortSafelist </span><span class="cov0" title="0">{
                if f.Sort == safeValue </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(f.Sort, "-")
                }</span>
        }
        <span class="cov0" title="0">panic("unsafe sort parameter: " + f.Sort)</span>
}

// Return the sort direction ("ASC" or "DESC") depending on the prefix character of the
// Sort field.
func (f Filters) sortDirection() string <span class="cov0" title="0">{
        if strings.HasPrefix(f.Sort, "-") </span><span class="cov0" title="0">{
                return "DESC"
        }</span>
        <span class="cov0" title="0">return "ASC"</span>
}

func (f Filters) limit() int <span class="cov0" title="0">{
        return f.PageSize
}</span>

func (f Filters) offset() int <span class="cov0" title="0">{
        return (f.Page - 1) * f.PageSize
}</span>

// limitInt32 returns the limit as int32, safe for use with database queries
func (f Filters) limitInt32() int32 <span class="cov0" title="0">{
        limit := f.limit()
        // Since we validate PageSize &lt;= 100, this is always safe
        return int32(limit) // #nosec G115 -- PageSize is validated to be &lt;= 100
}</span>

// offsetInt32 returns the offset as int32, safe for use with database queries
func (f Filters) offsetInt32() int32 <span class="cov0" title="0">{
        offset := f.offset()
        // Since we validate Page &lt;= 10M and PageSize &lt;= 100, max offset is ~1B which fits in int32
        return int32(offset) // #nosec G115 -- Validated bounds ensure this conversion is safe
}</span>

// The calculateMetadata() function calculates the appropriate pagination metadata
// values given the total number of records, current page, and page size values. Note
// that the last page value is calculated using the math.Ceil() function, which rounds
// up a float to the nearest integer. So, for example, if there were 12 records in total
// and a page size of 5, the last page value would be math.Ceil(12/5) = 3.
func calculateMetadata(totalRecords, page, pageSize int) Metadata <span class="cov0" title="0">{
        //fmt.Printf("calculateMetadata called with totalRecords: %d, page: %d, pageSize: %d\n", totalRecords, page, pageSize)
        if totalRecords == 0 </span><span class="cov0" title="0">{
                // Note that we return an empty Metadata struct if there are no records.
                return Metadata{}
        }</span>
        <span class="cov0" title="0">return Metadata{
                CurrentPage:  page,
                PageSize:     pageSize,
                FirstPage:    1,
                LastPage:     int(math.Ceil(float64(totalRecords) / float64(pageSize))),
                TotalRecords: totalRecords,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package data

import (
        "context"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/validator"
)

// contextGenerator() is a helper function that generates a new context.Context from a
// context.Context and a timeout duration.
func contextGenerator(ctx context.Context, timeout time.Duration) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return context.WithTimeout(ctx, timeout)
}</span>

func ValidateURLID(v *validator.Validator, stockID int64, fieldName string) <span class="cov0" title="0">{
        v.Check(stockID &gt; 0, fieldName, "must be a valid ID")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package data

import (
        "errors"

        "github.com/Blue-Davinci/leadhub-service/internal/database"
)

var (
        ErrGeneralRecordNotFound = errors.New("finance record not found")
        ErrGeneralEditConflict   = errors.New("edit conflict")
)

type Models struct {
        Tenants     TenantsModel
        Users       UserModel
        Tokens      TokenModel
        Permissions PermissionModel
        TradeLeads  TradeLeadModel
}

func NewModels(db *database.Queries) Models <span class="cov0" title="0">{
        return Models{
                Tenants:     TenantsModel{DB: db},
                Users:       UserModel{DB: db},
                Tokens:      TokenModel{DB: db},
                Permissions: PermissionModel{DB: db},
                TradeLeads:  TradeLeadModel{DB: db},
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package data

import (
        "context"
        "database/sql"
        "errors"
        "regexp"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/database"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
)

var (
        ErrDuplicatePermission = errors.New("duplicate permission")
        ErrPermissionNotFound  = errors.New("permission not found")
)
var (
        PermissionAdminWrite = "admin:write"
        PermissionAdminRead  = "admin:read"
)

// Define the PermissionModel type.
type PermissionModel struct {
        DB *database.Queries
}

type UserPermission struct {
        PermissionID int64    `json:"permission_id"`
        UserID       int64    `json:"user_id"`
        Permissions  []string `json:"permissions"`
}

func ValidatePermissionsAddition(v *validator.Validator, permissions *UserPermission) <span class="cov0" title="0">{
        v.Check(len(permissions.Permissions) != 0, "permissions", "must be provided")
        //v.Check()
        v.Check(permissions.UserID != 0, "user_id", "must be provided")
}</span>
func ValidatePermissionsDeletion(v *validator.Validator, userID int64, permissionCode string) <span class="cov0" title="0">{
        v.Check(permissionCode != "", "codes", "must be provided")
        //v.Check()
        v.Check(userID != 0, "user_id", "must be provided")
}</span>

func ValidatePermission(v *validator.Validator, permissionCode string) <span class="cov0" title="0">{
        v.Check(permissionCode != "", "codes", "must be provided")
        //check permission validity
        v.Check(IsValidPermissionFormat(permissionCode), "permissions", "must be in the format 'permission:code'")
}</span>

// Function to check if a permission matches the format "permission:code"
func IsValidPermissionFormat(permission string) bool <span class="cov0" title="0">{
        // Compile the regular expression
        re := regexp.MustCompile(`^[a-zA-Z]+:[a-zA-Z]+$`)
        // Check if the permission matches the format
        return re.MatchString(permission)
}</span>

// Make a slice to hold the the permission codes (like
// "admin:read" and "admin:write") for an admin user.
type Permissions []string

// Add a helper method to check whether the Permissions slice contains a specific
// permission code.
func (p Permissions) Include(code string) bool <span class="cov0" title="0">{
        for i := range p </span><span class="cov0" title="0">{
                if code == p[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetAllPermissions() just returns all available permissions currently in the system.
func (m PermissionModel) GetAllPermissions() ([]*UserPermission, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        permissions, err := m.DB.GetAllPermissions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var allPermissions []*UserPermission
        for _, permission := range permissions </span><span class="cov0" title="0">{
                allPermissions = append(allPermissions, &amp;UserPermission{
                        PermissionID: permission.ID,
                        Permissions:  []string{permission.Code},
                })
        }</span>

        <span class="cov0" title="0">return allPermissions, nil</span>
}

// GetAllPermissionsForUser() is a method that retrieves all permissions for a specific user
// from the database. It expects the user's ID as input and returns a slice of permission codes.
func (m PermissionModel) GetAllPermissionsForUser(userID int64) (Permissions, error) <span class="cov0" title="0">{
        // set up context
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()
        // create our permissions
        var permissions Permissions
        // call the database method
        dbPermissions, err := m.DB.GetAllPermissionsForUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, permission := range dbPermissions </span><span class="cov0" title="0">{
                permissions = append(permissions, permission)
        }</span>
        // return permissions
        <span class="cov0" title="0">return permissions, nil</span>
}

// AddPermissionsForUser() is an admin method that adds permissions for a specific user
// in the database. It expects the user's ID and a slice of permission codes as input.
func (m PermissionModel) AddPermissionsForUser(userID int64, codes ...string) (*UserPermission, error) <span class="cov0" title="0">{
        // setup our context timeout
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()
        // insert our permissions
        queryResult, err := m.DB.AddPermissionsForUser(ctx, database.AddPermissionsForUserParams{
                UserID:  userID,
                Column2: codes,
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case err.Error() == `pq: duplicate key value violates unique constraint "users_permissions_pkey"`:<span class="cov0" title="0">
                        return nil, ErrDuplicatePermission</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // create our permissions
        <span class="cov0" title="0">userPermission := &amp;UserPermission{
                PermissionID: queryResult.PermissionID,
                UserID:       queryResult.UserID,
                Permissions:  codes,
        }
        // return the permissions
        return userPermission, nil</span>
}

// DeletePermissionsForUser() is an admin method that deletes permissions for a specific user
// in the database. It expects the user's ID and a permission code as input.
func (m PermissionModel) DeletePermissionsForUser(userID int64, permissionCode string) (int64, error) <span class="cov0" title="0">{
        // Setup our context timeout
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        // Execute the deletion query
        permissionID, err := m.DB.DeletePermissionsForUser(ctx, database.DeletePermissionsForUserParams{
                UserID: userID,
                Code:   permissionCode,
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return 0, ErrPermissionNotFound</span>
                default:<span class="cov0" title="0">
                        return 0, err</span>
                }
        }

        <span class="cov0" title="0">return permissionID, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package data

import (
        "context"
        "database/sql"
        "errors"
        "strings"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/database"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
)

type TenantsModel struct {
        DB *database.Queries
}

var (
        ErrTenantAlreadyExists = errors.New("tenant already exists")
)

const (
        DefaultTenantManagerDBContextTimeout = 5 * time.Second
)

type Tenant struct {
        ID           int64     `json:"id"`
        Name         string    `json:"name"`
        ContactEmail string    `json:"contact_email"`
        Description  string    `json:"description"`
        Version      int32     `json:"version"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

func ValidateTenant(v *validator.Validator, tenant *Tenant) <span class="cov8" title="1">{
        // Check if the tenant name is provided and valid
        v.Check(tenant.Name != "", "name", "must be provided")

        // Check if the contact email is provided and valid
        ValidateEmail(v, tenant.ContactEmail)

        // Check if the description is not too long
        v.Check(len(tenant.Description) &lt;= 500, "description", "must not be more than 500 characters long")
}</span>

// GetTenantByID() retrieves a tenant by its ID from the database.
func (m TenantsModel) GetTenantByID(id int64) (*Tenant, error) <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultTenantManagerDBContextTimeout)
        defer cancel()
        // get tenant by ID
        tenant, err := m.DB.GetTenantByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // populate the tenant struct
        <span class="cov0" title="0">return populateTenants(tenant), nil</span>
}

// AdminGetAllTenants() retrieves all tenants from the database.
func (m TenantsModel) AdminGetAllTenants(tenantName string, filters Filters) ([]*Tenant, Metadata, error) <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultTenantManagerDBContextTimeout)
        defer cancel()
        // get all tenants
        tenants, err := m.DB.AdminGetAllTenants(ctx, database.AdminGetAllTenantsParams{
                Column1: tenantName,
                Limit:   filters.limitInt32(),
                Offset:  filters.offsetInt32(),
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, Metadata{}, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, Metadata{}, err</span>
                }
        }
        // check length of tenants
        <span class="cov0" title="0">if len(tenants) == 0 </span><span class="cov0" title="0">{
                return nil, Metadata{}, ErrGeneralRecordNotFound
        }</span>
        // populate the tenants slice
        <span class="cov0" title="0">tenantRows := []*Tenant{}
        totalRows := 0
        for _, tenantRow := range tenants </span><span class="cov0" title="0">{
                totalRows = int(tenantRow.TotalCount)
                tenantRows = append(tenantRows, populateTenants(tenantRow))
        }</span>
        // metadata
        <span class="cov0" title="0">metadata := calculateMetadata(totalRows, filters.Page, filters.PageSize)
        // return
        return tenantRows, metadata, nil</span>
}

// CreateTenant() creates a new tenant in the database.
func (m TenantsModel) CreateTenant(tenant *Tenant) error <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultTenantManagerDBContextTimeout)
        defer cancel()

        // Create the tenant in the database
        newTenant, err := m.DB.CreateTenant(ctx, database.CreateTenantParams{
                Name:         tenant.Name,
                ContactEmail: tenant.ContactEmail,
                Description:  sql.NullString{String: tenant.Description, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.Contains(err.Error(), "tenants_name_key"):<span class="cov0" title="0">
                        return ErrTenantAlreadyExists</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        // Populate the tenant struct with the new tenant data
        <span class="cov0" title="0">tenant.ID = newTenant.ID
        tenant.Version = newTenant.Version
        tenant.CreatedAt = newTenant.CreatedAt
        tenant.UpdatedAt = newTenant.UpdatedAt
        // we are good to go
        return nil</span>
}

// UpdateTenant() updates an existing tenant in the database.
func (m TenantsModel) UpdateTenant(tenant *Tenant, versionID int32) error <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultTenantManagerDBContextTimeout)
        defer cancel()

        // Update the tenant in the database
        updatedTenant, err := m.DB.UpdateTenant(ctx, database.UpdateTenantParams{
                ID:           tenant.ID,
                Name:         tenant.Name,
                ContactEmail: tenant.ContactEmail,
                Description:  sql.NullString{String: tenant.Description, Valid: true},
                Version:      versionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return ErrGeneralEditConflict</span>
                case strings.Contains(err.Error(), "tenants_name_key"):<span class="cov0" title="0">
                        return ErrTenantAlreadyExists</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        // update the tenant struct with the updated data
        <span class="cov0" title="0">tenant.UpdatedAt = updatedTenant.UpdatedAt
        tenant.Version = updatedTenant.Version
        // we are good to go
        return nil</span>
}

func populateTenants(tenantRow any) *Tenant <span class="cov0" title="0">{
        switch tenantRow := tenantRow.(type) </span>{
        case database.Tenant:<span class="cov0" title="0">
                return &amp;Tenant{
                        ID:           tenantRow.ID,
                        Name:         tenantRow.Name,
                        ContactEmail: tenantRow.ContactEmail,
                        Description:  tenantRow.Description.String,
                        Version:      tenantRow.Version,
                        CreatedAt:    tenantRow.CreatedAt,
                        UpdatedAt:    tenantRow.UpdatedAt,
                }</span>
        case database.AdminGetAllTenantsRow:<span class="cov0" title="0">
                return &amp;Tenant{
                        ID:           tenantRow.ID,
                        Name:         tenantRow.Name,
                        ContactEmail: tenantRow.ContactEmail,
                        Description:  tenantRow.Description.String,
                        Version:      tenantRow.Version,
                        CreatedAt:    tenantRow.CreatedAt,
                        UpdatedAt:    tenantRow.UpdatedAt,
                }</span>
        default:<span class="cov0" title="0">
                // return nil
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package data

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base32"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/database"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
)

type TokenModel struct {
        DB *database.Queries
}

const (
        DefaultTokenExpiryTime       = 72 * time.Hour
        DefaultTokenDBContextTimeout = 5 * time.Second
)

// Define constants for the token scope.
const (
        ScopeActivation     = "activation"
        ScopeAuthentication = "authentication"
        ScopePasswordReset  = "password-reset"
        ScopeMFALogin       = "mfa-login"
        ScopeRecovery       = "recovery-codes"
)

// Define a Token struct to hold the data for an individual token. This includes the
// plaintext and hashed versions of the token, associated user ID, expiry time and
// scope.
type Token struct {
        Plaintext string    `json:"token"`
        Hash      []byte    `json:"-"`
        UserID    int64     `json:"-"`
        Expiry    time.Time `json:"expiry"`
        Scope     string    `json:"-"`
}

// Check that the plaintext token has been provided and is exactly 26 bytes long.
func ValidateTokenPlaintext(v *validator.Validator, tokenPlaintext string) <span class="cov0" title="0">{
        v.Check(tokenPlaintext != "", "token", "must be provided")
        v.Check(len(tokenPlaintext) == 26, "token", "must be valid")
}</span>

// Create a Token instance containing the user ID, expiry, and scope information.
// We add the provided ttl (time-to-live) duration parameter to the
// current time to get the expiry time
func generateToken(userID int64, ttl time.Duration, scope string) (*Token, error) <span class="cov0" title="0">{
        token := &amp;Token{
                UserID: userID,
                Expiry: time.Now().Add(ttl),
                Scope:  scope,
        }
        // Initialize a zero-valued byte slice with a length of 16 bytes.
        randomBytes := make([]byte, 16)
        // Use the Read() function from the crypto/rand package to fill the byte slice random bytes
        _, err := rand.Read(randomBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Encode the byte slice to a base-32-encoded string and assign it to the token
        // Plaintext field.
        <span class="cov0" title="0">token.Plaintext = base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(randomBytes)
        // Generate a SHA-256 hash of the plaintext token string. This will be the value
        // that we store in the `hash` field of our database table.
        hash := sha256.Sum256([]byte(token.Plaintext))
        token.Hash = hash[:]
        return token, nil</span>
}

func (m TokenModel) New(userID int64, ttl time.Duration, scope string) (*Token, error) <span class="cov0" title="0">{
        api_key, err := generateToken(userID, ttl, scope)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //fmt.Printf("API Key: %v\n || User ID: %d", api_key, userID)
        // insert the api key into the database
        <span class="cov0" title="0">err = m.Insert(api_key)
        return api_key, err</span>
}

func (m TokenModel) Insert(api_key *Token) error <span class="cov0" title="0">{
        // create our timeout context. All of them will just be 5 seconds
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _, err := m.DB.InsertApiKey(ctx, database.InsertApiKeyParams{
                ApiKey: api_key.Hash,
                UserID: api_key.UserID,
                Expiry: api_key.Expiry,
                Scope:  api_key.Scope,
        })
        return err
}</span>

// DeleteAllForUser() deletes all tokens for a specific user and scope.
func (m TokenModel) DeleteAllForUser(scope string, userID int64) error <span class="cov0" title="0">{
        // create our timeout context. All of them will just be 5 seconds
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        err := m.DB.DeletAllAPIKeysForUser(ctx, database.DeletAllAPIKeysForUserParams{
                UserID: userID,
                Scope:  scope,
        })
        return err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package data

import (
        "context"
        "database/sql"
        "errors"
        "strings"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/database"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
        "github.com/shopspring/decimal"
)

type TradeLeadModel struct {
        DB *database.Queries
}

const (
        DefaultLeadManagerDBContextTimeout = 5 * time.Second
)

var (
        ErrInvalidTenantReference = errors.New("invalid tenant reference")
        ErrInvalidTradeLeadStatus = errors.New("invalid trade lead status")
)

// TradeLead represents a trade lead in the system.
type TradeLead struct {
        ID          int64           `json:"id"`
        TenantID    int64           `json:"tenant_id"`
        Title       string          `json:"title"`
        Description string          `json:"description"`
        Status      string          `json:"status"`
        Value       decimal.Decimal `json:"value"`
        Version     int32           `json:"version"`
        CreatedAt   time.Time       `json:"created_at"`
        UpdatedAt   time.Time       `json:"updated_at"`
}
type TradeStats struct {
        TotalLeads         decimal.Decimal `json:"total_leads"`
        TotalVerifiedValue decimal.Decimal `json:"total_verified_value"`
        VerifiedLeads      decimal.Decimal `json:"verified_leads"`
}

// ValidateTradeLead validates the fields of a TradeLead.
func ValidateTradeLead(v *validator.Validator, lead *TradeLead) <span class="cov8" title="1">{
        // should validate tenant ID, title, description, and value
        v.Check(lead.Title != "", "title", "must be provided")
        v.Check(len(lead.Description) &lt;= 1000, "description", "must not be more than 1000 characters long")
        v.Check(lead.Value.GreaterThan(decimal.Zero), "value", "must be a non-negative or non-zero number")
}</span>

// CreateTradeLead() creates a new trade lead in the database.
// we accept the tenant_id, and a *TradeLead struct as input.
func (m TradeLeadModel) CreateTradeLead(tenantID int64, tenantLead *TradeLead) error <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultLeadManagerDBContextTimeout)
        defer cancel()
        // create the trade lead in the database
        newLead, err := m.DB.CreateTradeLead(ctx, database.CreateTradeLeadParams{
                TenantID:    tenantID,
                Title:       tenantLead.Title,
                Description: sql.NullString{String: tenantLead.Description, Valid: true},
                Value:       tenantLead.Value.String(),
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.Contains(err.Error(), "trade_leads_tenant_id_fkey"):<span class="cov0" title="0">
                        return ErrInvalidTenantReference</span>
                case strings.Contains(err.Error(), "trade_leads_status_check"):<span class="cov0" title="0">
                        return ErrInvalidTradeLeadStatus</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        // Populate the trade lead struct with the new data
        <span class="cov0" title="0">tenantLead.ID = newLead.ID
        tenantLead.TenantID = newLead.TenantID
        tenantLead.Version = newLead.Version
        tenantLead.Status = newLead.Status
        tenantLead.CreatedAt = newLead.CreatedAt
        tenantLead.UpdatedAt = newLead.UpdatedAt
        // we are good to go
        return nil</span>
}

// GetTradeLeadByID() retrieves a trade lead by its ID from the database.
func (m TradeLeadModel) GetTradeLeadByID(id int64) (*TradeLead, error) <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultLeadManagerDBContextTimeout)
        defer cancel()
        // get trade lead by ID
        lead, err := m.DB.GetTradeLeadByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // populate the trade lead struct
        <span class="cov0" title="0">tradeLead := populateTradeLeads(lead)
        // return the trade lead
        return tradeLead, nil</span>
}

// GetAllLeadsByTenantID() retrieves all trade leads for a specific tenant ID from the database.
// It supports both filtering and pagination.
func (m TradeLeadModel) GetAllLeadsByTenantID(tenantID int64, name string, filters Filters) ([]*TradeLead, Metadata, error) <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultLeadManagerDBContextTimeout)
        defer cancel()
        // get all trade leads by tenant ID
        leads, err := m.DB.GetAllLeadsByTenantID(ctx, database.GetAllLeadsByTenantIDParams{
                TenantID: tenantID,
                Column2:  name,
                Limit:    filters.limitInt32(),
                Offset:   filters.offsetInt32(),
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, Metadata{}, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, Metadata{}, err</span>
                }
        }
        // chekc the length of leads
        <span class="cov0" title="0">if len(leads) == 0 </span><span class="cov0" title="0">{
                return nil, Metadata{}, ErrGeneralRecordNotFound
        }</span>
        // populate the leads slice
        <span class="cov0" title="0">leadRows := []*TradeLead{}
        totalRows := 0
        for _, leadRow := range leads </span><span class="cov0" title="0">{
                totalRows = int(leadRow.TotalCount)
                leadRows = append(leadRows, populateTradeLeads(leadRow))
        }</span>
        // metadata
        <span class="cov0" title="0">metadata := calculateMetadata(totalRows, filters.Page, filters.PageSize)
        // return
        return leadRows, metadata, nil</span>
}

// AdminGetAllTradeLeads() retrieves all trade leads from the database.
func (m TradeLeadModel) AdminGetAllTradeLeads(name string, filters Filters) ([]*TradeLead, Metadata, error) <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultLeadManagerDBContextTimeout)
        defer cancel()
        // get all trade leads
        leads, err := m.DB.AdminGetAllTradeLeads(ctx, database.AdminGetAllTradeLeadsParams{
                Column1: name,
                Limit:   filters.limitInt32(),
                Offset:  filters.offsetInt32(),
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, Metadata{}, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, Metadata{}, err</span>
                }
        }
        // check length of leads
        <span class="cov0" title="0">if len(leads) == 0 </span><span class="cov0" title="0">{
                return nil, Metadata{}, ErrGeneralRecordNotFound
        }</span>
        // populate the leads slice
        <span class="cov0" title="0">leadRows := []*TradeLead{}
        totalRows := 0
        for _, leadRow := range leads </span><span class="cov0" title="0">{
                totalRows = int(leadRow.TotalCount)
                leadRows = append(leadRows, populateTradeLeads(leadRow))
        }</span>
        // metadata
        <span class="cov0" title="0">metadata := calculateMetadata(totalRows, filters.Page, filters.PageSize)
        // return
        return leadRows, metadata, nil</span>
}

// AdminUpdateTradeLeadStatus() updates the status of a trade lead in the database.
func (m TradeLeadModel) AdminUpdateTradeLeadStatus(leadID int64, version int32, lead *TradeLead) error <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultLeadManagerDBContextTimeout)
        defer cancel()
        // update the trade lead status in the database
        updatedLead, err := m.DB.AdminUpdateTradeLeadStatus(ctx, database.AdminUpdateTradeLeadStatusParams{
                ID:      leadID,
                Version: version,
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.Contains(err.Error(), "trade_leads_status_check"):<span class="cov0" title="0">
                        return ErrInvalidTradeLeadStatus</span>
                //sqlnoRows error is returned when no rows are found
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        // update lead
        <span class="cov0" title="0">lead.Version = updatedLead.Version
        lead.Status = updatedLead.Status
        lead.UpdatedAt = updatedLead.UpdatedAt
        return nil</span>
}

// AdminGetTRadeLeadStats() retrieves statistics about trade leads from the database.
func (m TradeLeadModel) AdminGetTradeLeadStats() (*TradeStats, error) <span class="cov0" title="0">{
        ctx, cancel := contextGenerator(context.Background(), DefaultLeadManagerDBContextTimeout)
        defer cancel()
        // get trade lead stats
        stats, err := m.DB.AdminGetTRadeLeadStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // Process the stats as needed
        <span class="cov0" title="0">tradeStats := &amp;TradeStats{
                TotalLeads:         decimal.RequireFromString(stats.TotalLeads),
                TotalVerifiedValue: decimal.RequireFromString(stats.TotalVerifiedValue),
                VerifiedLeads:      decimal.RequireFromString(stats.VerifiedLeads),
        }
        return tradeStats, nil</span>
}

func populateTradeLeads(tradeLeadRow any) *TradeLead <span class="cov0" title="0">{
        switch leadRow := tradeLeadRow.(type) </span>{
        case database.TradeLead:<span class="cov0" title="0">
                return &amp;TradeLead{
                        ID:          leadRow.ID,
                        TenantID:    leadRow.TenantID,
                        Title:       leadRow.Title,
                        Description: leadRow.Description.String,
                        Status:      leadRow.Status,
                        Value:       decimal.RequireFromString(leadRow.Value),
                        Version:     leadRow.Version,
                        CreatedAt:   leadRow.CreatedAt,
                        UpdatedAt:   leadRow.UpdatedAt,
                }</span>
        case database.GetAllLeadsByTenantIDRow:<span class="cov0" title="0">
                return &amp;TradeLead{
                        ID:          leadRow.ID,
                        TenantID:    leadRow.TenantID,
                        Title:       leadRow.Title,
                        Description: leadRow.Description.String,
                        Status:      leadRow.Status,
                        Value:       decimal.RequireFromString(leadRow.Value),
                        Version:     leadRow.Version,
                        CreatedAt:   leadRow.CreatedAt,
                        UpdatedAt:   leadRow.UpdatedAt,
                }</span>
        case database.AdminGetAllTradeLeadsRow:<span class="cov0" title="0">
                return &amp;TradeLead{
                        ID:          leadRow.ID,
                        TenantID:    leadRow.TenantID,
                        Title:       leadRow.Title,
                        Description: leadRow.Description.String,
                        Status:      leadRow.Status,
                        Value:       decimal.RequireFromString(leadRow.Value),
                        Version:     leadRow.Version,
                        CreatedAt:   leadRow.CreatedAt,
                        UpdatedAt:   leadRow.UpdatedAt,
                }</span>
        default:<span class="cov0" title="0">
                return nil</span> // or handle the error as needed
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package data

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "errors"
        "strings"
        "time"

        "github.com/Blue-Davinci/leadhub-service/internal/database"
        "github.com/Blue-Davinci/leadhub-service/internal/validator"
        "golang.org/x/crypto/bcrypt"
)

type UserModel struct {
        DB *database.Queries
}

const (
        DefaultUserManagerDBContextTimeout = 5 * time.Second
)

var (
        ErrDuplicateEmail  = errors.New("duplicate email address")
        ErrInvalidTenantID = errors.New("invalid tenant id")
)

// Declare a new AnonymousUser variable.
var AnonymousUser = &amp;User{}

// Check if a User instance is the AnonymousUser.
func (u *User) IsAnonymous() bool <span class="cov0" title="0">{
        return u == AnonymousUser
}</span>

// Create a custom password type which is a struct containing the plaintext and hashed
// versions of the password for a user.
type password struct {
        plaintext *string
        hash      []byte
}

// set() calculates the bcrypt hash of a plaintext password, and stores both
// the hash and the plaintext versions in the struct.
func (p *password) Set(plaintextPassword string) error <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(plaintextPassword), 12)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">p.plaintext = &amp;plaintextPassword
        p.hash = hash
        return nil</span>
}

// The Matches() method checks whether the provided plaintext password matches the
// hashed password stored in the struct, returning true if it matches and false
// otherwise.
func (p *password) Matches(plaintextPassword string) (bool, error) <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword(p.hash, []byte(plaintextPassword))
        if err != nil </span><span class="cov0" title="0">{
                //fmt.Printf("&gt;&gt;&gt;&gt;&gt; Plain text: %s\nHash: %v\n", plaintextPassword, p.hash)
                switch </span>{
                case errors.Is(err, bcrypt.ErrMismatchedHashAndPassword):<span class="cov0" title="0">
                        return false, nil</span>
                default:<span class="cov0" title="0">
                        return false, err</span>
                }
        }
        <span class="cov0" title="0">return true, nil</span>
}

// The user struct represents a user account in our application. It contains fields for
// the user ID, created timestamp, name, email address, password hash, and activation data
type User struct {
        ID        int64     `json:"id"`
        TenantID  int64     `json:"tenant_id"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
        Password  password  `json:"-"`
        Activated bool      `json:"-"`
        Version   int32     `json:"-"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type UserSubInfo struct {
        Name      string    `json:"name"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at"`
}

func ValidateEmail(v *validator.Validator, email string) <span class="cov8" title="1">{
        v.Check(email != "", "email", "must be provided")
        v.Check(validator.Matches(email, validator.EmailRX), "email", "must be a valid email address")
}</span>
func ValidateName(v *validator.Validator, name string) <span class="cov0" title="0">{
        v.Check(name != "", "email", "must be provided")
        v.Check(len(name) &lt;= 500, "name", "must not be more than 500 bytes long")
}</span>
func ValidatePasswordPlaintext(v *validator.Validator, password string) <span class="cov0" title="0">{
        v.Check(password != "", "password", "must be provided")
        v.Check(len(password) &gt;= 8, "password", "must be at least 8 bytes long")
        v.Check(len(password) &lt;= 72, "password", "must not be more than 72 bytes long")
}</span>
func ValidateUser(v *validator.Validator, user *User) <span class="cov0" title="0">{
        // Call the standalone ValidateName() helper.
        ValidateName(v, user.Name)
        // Call the standalone ValidateEmail() helper.
        ValidateEmail(v, user.Email)
        // If the plaintext password is not nil, call the standalone
        // ValidatePasswordPlaintext() helper.
        if user.Password.plaintext != nil </span><span class="cov0" title="0">{
                ValidatePasswordPlaintext(v, *user.Password.plaintext)
        }</span>
        // If the password hash is ever nil, this will be due to a logic error in our
        // codebase. So rather than adding an error to the validation map we
        // raise a panic instead.
        <span class="cov0" title="0">if user.Password.hash == nil </span><span class="cov0" title="0">{
                panic("missing password hash for user")</span>
        }
}

// Insert() creates a new User and returns success on completion.
// The function will also check for the uniqueness of the user email.
// Note, this will only "Sign Up" our USER, not log them in.
func (m UserModel) Insert(user *User) error <span class="cov0" title="0">{
        // Create a new context with a 5 second timeout
        ctx, cancel := contextGenerator(context.Background(), DefaultUserManagerDBContextTimeout)
        defer cancel()
        createduser, err := m.DB.CreateUser(ctx, database.CreateUserParams{
                TenantID:     user.TenantID,
                Name:         user.Name,
                Email:        user.Email,
                PasswordHash: user.Password.hash,
                Activated:    user.Activated,
        })

        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.Contains(err.Error(), "users_email_key"):<span class="cov0" title="0">
                        return ErrDuplicateEmail</span>
                case strings.Contains(err.Error(), "users_tenant_id_fkey"):<span class="cov0" title="0">
                        return ErrInvalidTenantID</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        // fill in the user struct with the created user data
        <span class="cov0" title="0">user.ID = createduser.ID
        user.CreatedAt = createduser.CreatedAt
        user.Version = createduser.Version
        // If we reach this point, the user was successfully created
        return nil</span>
}

// GetForToken() retrieves a user by their API token and scope.
// It calculates the sha256 hash of the provided plaintext token, and then queries
// the database for a user with that token and scope. If found, it returns a User
// struct populated with the user's data. If not found, it returns an error.
func (m UserModel) GetForToken(tokenScope, tokenPlaintext string) (*User, error) <span class="cov0" title="0">{
        // Calculate sha256 hash of plaintext
        tokenHash := sha256.Sum256([]byte(tokenPlaintext))
        ctx, cancel := contextGenerator(context.Background(), DefaultUserManagerDBContextTimeout)
        defer cancel()
        // get the user
        user, err := m.DB.GetForToken(ctx, database.GetForTokenParams{
                ApiKey: tokenHash[:],
                Scope:  tokenScope,
                Expiry: time.Now(),
        })
        // check for any error
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // make a user
        <span class="cov0" title="0">tokenuser := populateUser(user)
        // fill in the user data
        return tokenuser, nil</span>
}

// GetByEmail() retrieves a user by their email address.
// It creates a new context with a 5 second timeout, queries the database for a user
// with the provided email, and returns a populated User struct if found. If no user
// is found, it returns an ErrGeneralRecordNotFound error. If any other error occurs,
// it returns that error.
func (m UserModel) GetByEmail(email string) (*User, error) <span class="cov0" title="0">{
        // Create a new context with a 5 second timeout
        ctx, cancel := contextGenerator(context.Background(), DefaultUserManagerDBContextTimeout)
        defer cancel()
        // get the user by email
        user, err := m.DB.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, ErrGeneralRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        // populate the user struct
        <span class="cov0" title="0">populatedUser := populateUser(user)
        // no issue returning the populated user
        return populatedUser, nil</span>
}

// UpdateUser() updates an existing user in the database.
func (m UserModel) UpdateUser(user *User) error <span class="cov0" title="0">{
        // Create a new context with a 5 second timeout
        ctx, cancel := contextGenerator(context.Background(), DefaultUserManagerDBContextTimeout)
        defer cancel()
        // Update the user in the database
        updatedUser, err := m.DB.UpdateUser(ctx, database.UpdateUserParams{
                ID:           user.ID,
                Name:         user.Name,
                Email:        user.Email,
                PasswordHash: user.Password.hash,
                Activated:    user.Activated,
                Version:      int32(user.Version),
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.Contains(err.Error(), "users_email_key"):<span class="cov0" title="0">
                        return ErrDuplicateEmail</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        <span class="cov0" title="0">user.UpdatedAt = updatedUser.UpdatedAt
        return nil</span>
}

// populateUser() takes a userRow of type any and attempts to convert it to a User struct.
// It checks the type of userRow, and if it is of type database.User, it creates a new
// password struct instance with the user's password hash. It then returns a pointer to a
// User struct populated with the user's ID, TenantID, Name, Email, Password, Activated status,
func populateUser(userRow any) *User <span class="cov0" title="0">{
        switch user := userRow.(type) </span>{
        case database.User:<span class="cov0" title="0">
                // Create a new password struct instance for the user.
                userPassword := password{
                        hash: user.PasswordHash,
                }
                return &amp;User{
                        ID:        user.ID,
                        TenantID:  user.TenantID,
                        Name:      user.Name,
                        Email:     user.Email,
                        Password:  userPassword,
                        Activated: user.Activated,
                        Version:   user.Version,
                        CreatedAt: user.CreatedAt,
                        UpdatedAt: user.UpdatedAt,
                }</span>
        default:<span class="cov0" title="0">
                // return nil if the userRow is not of type database.User
                return nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
